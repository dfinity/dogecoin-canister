//! Integration tests for utxo-dump tool
//!
//! These tests run the actual utxo-dump binary against test chainstate data
//! and verify the output consistency using file hashing.
//!
//! ## Usage
//!
//! To run the integration tests:
//! ```bash
//! cargo test --test integration_tests
//! ```

use flate2::read::GzDecoder;
use sha2::{Digest, Sha256};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use tar::Archive;
use tempfile::TempDir;

// Expected hash of utxo-dump output for Bitcoin mainnet chainstate data
// (present as `data/chainstate_btc_mainnet_250k.tar.gz`).
//
// The chainstate tar.gz file has been generated by syncing the Bitcoin blockchain up to height 250k:
// ```bash
// ./bitcoin-28.0/bin/bitcoind -datadir="./data" -stopatheight=250000
// tar -czf chainstate_btc_mainnet_250k.tar.gz ./data/chainstate/
// ```
//
// Note: the result is the same as with running the bitcoin-utxo-dump tool from: <https://github.com/in3rsha/bitcoin-utxo-dump/tree/9b1c015308f779ac529083ed7922cc551b8ddb53>
const SHA256_OUTPUT_BTC_MAINNET_250K: &str =
    "a9b6bb33239a6865f9251e2f7d8ed06920782d4735c0b331f2a496061c2e2e0e";

// Expected hash of utxo-dump output for Dogecoin mainnet chainstate data
// (present as `data/chainstate_doge_mainnet_350135.tar.gz`).
//
// The chainstate tar.gz file has been generated by syncing the Dogecoin blockchain, stopping the
// daemon after height 350,135:
// ```bash
// ./dogecoin-1.14.9/bin/dogecoind -datadir="./data"
// tar -czf chainstate_doge_mainnet_350135.tar.gz ./data/chainstate/
// ```
const SHA256_OUTPUT_DOGE_MAINNET_350_135: &str =
    "56a909328102dd8f177e6e264e353f0134b26f073e83e93b3efc89c5ef3daed3";

/// Runs utxo-dump against test chainstate data and verifies the output hash matches the expected value
#[test]
fn test_utxo_dump_bitcoin_mainnet_regression() {
    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let output_file = temp_dir.path().join("bitcoin_mainnet_250k_output.csv");

    let test_chainstate_path = extract_chainstate_data(&temp_dir, "chainstate_btc_mainnet_250k.tar.gz")
        .expect("Failed to extract Bitcoin mainnet chainstate data. Make sure tests/data/chainstate_btc_mainnet_250k.tar.gz exists.");

    println!("Testing with Bitcoin mainnet chainstate (up to height 250k)...");

    // Run utxo-dump binary with Bitcoin setting
    let output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "utxo-dump",
            "--",
            "--db",
            test_chainstate_path.to_str().unwrap(),
            "--output",
            output_file.to_str().unwrap(),
            "--blockchain",
            "bitcoin",
            "--quiet",
        ])
        .current_dir(".")
        .output()
        .expect("Failed to run utxo-dump");

    if !output.status.success() {
        panic!(
            "utxo-dump failed with Bitcoin mainnet chainstate!\nExit code: {}\nstdout: {}\nstderr: {}", 
            output.status.code().unwrap_or(-1),
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );
    }

    assert!(output_file.exists(), "Output file was not created");
    let file_contents = fs::read(&output_file).expect("Failed to read output file");
    assert!(!file_contents.is_empty(), "Output file is empty");

    let mut hasher = Sha256::new();
    hasher.update(&file_contents);
    let result_hash = hasher.finalize();
    let hash_hex = format!("{:x}", result_hash);

    let output_str = String::from_utf8_lossy(&file_contents);

    assert!(
        output_str.contains("height,txid,vout"),
        "Output doesn't contain expected CSV header"
    );

    let line_count = output_str.lines().count();
    println!("=== BITCOIN MAINNET TEST RESULTS ===");
    println!("Output file hash: {}", hash_hex);
    println!("Output file size: {} bytes", file_contents.len());
    println!("Total lines: {} (including header)", line_count);

    println!("First few lines of output:");
    for (i, line) in output_str.lines().take(10).enumerate() {
        println!("  {}: {}", i + 1, line);
    }

    assert!(
        line_count > 1,
        "Should have at least header + some UTXO entries"
    );

    assert_eq!(
        hash_hex, SHA256_OUTPUT_BTC_MAINNET_250K,
        "Bitcoin mainnet output hash does not match expected value"
    );
}

/// Runs utxo-dump against test chainstate data and verifies the output hash matches the expected value
#[test]
fn test_utxo_dump_dogecoin_mainnet_regression() {
    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let output_file = temp_dir.path().join("dogecoin_mainnet_350135_output.csv");

    let test_chainstate_path = extract_chainstate_data(&temp_dir, "chainstate_doge_mainnet_350135.tar.gz")
        .expect("Failed to extract Dogecoin mainnet chainstate data. Make sure tests/data/chainstate_doge_mainnet_350135.tar.gz exists.");

    println!("Testing with Dogecoin mainnet chainstate (up to height 350,135)...");

    // Run utxo-dump binary with Dogecoin setting
    let output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "utxo-dump",
            "--",
            "--db",
            test_chainstate_path.to_str().unwrap(),
            "--output",
            output_file.to_str().unwrap(),
            "--blockchain",
            "dogecoin",
            "--quiet",
        ])
        .current_dir(".")
        .output()
        .expect("Failed to run utxo-dump");

    if !output.status.success() {
        panic!(
            "utxo-dump failed with Dogecoin mainnet chainstate!\nExit code: {}\nstdout: {}\nstderr: {}",
            output.status.code().unwrap_or(-1),
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );
    }

    assert!(output_file.exists(), "Output file was not created");
    let file_contents = fs::read(&output_file).expect("Failed to read output file");
    assert!(!file_contents.is_empty(), "Output file is empty");

    let mut hasher = Sha256::new();
    hasher.update(&file_contents);
    let result_hash = hasher.finalize();
    let hash_hex = format!("{:x}", result_hash);

    let output_str = String::from_utf8_lossy(&file_contents);

    assert!(
        output_str.contains("height,txid,vout"),
        "Output doesn't contain expected CSV header"
    );

    let line_count = output_str.lines().count();
    println!("=== DOGECOIN MAINNET TEST RESULTS ===");
    println!("Output file hash: {}", hash_hex);
    println!("Output file size: {} bytes", file_contents.len());
    println!("Total lines: {} (including header)", line_count);

    println!("First few lines of output:");
    for (i, line) in output_str.lines().take(10).enumerate() {
        println!("  {}: {}", i + 1, line);
    }

    assert!(
        line_count > 1,
        "Should have at least header + some UTXO entries"
    );

    assert_eq!(
        hash_hex, SHA256_OUTPUT_DOGE_MAINNET_350_135,
        "Dogecoin mainnet output hash does not match expected value"
    );
}

/// Find the tar.gz file in the tests/data directory
fn find_test_chainstate_path(filename: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {
    // Try multiple possible locations for the test data
    let possible_paths = [
        PathBuf::from("tests/data").join(filename),
        PathBuf::from("data").join(filename),
        PathBuf::from("../tests/data").join(filename),
    ];

    for path in &possible_paths {
        if path.exists() {
            return Ok(path.clone());
        }
    }

    Err(format!(
        "Test data file '{}' not found. Tried locations:\n{}",
        filename,
        possible_paths
            .iter()
            .map(|p| format!("  - {}", p.display()))
            .collect::<Vec<_>>()
            .join("\n")
    )
    .into())
}

/// Extract the tar.gz file and return the path to the extracted chainstate directory
fn extract_chainstate_data(
    temp_dir: &TempDir,
    filename: &str,
) -> Result<PathBuf, Box<dyn std::error::Error>> {
    let test_data_path = find_test_chainstate_path(filename)?;

    let tar_gz_file = fs::File::open(&test_data_path)?;
    let tar_decoder = GzDecoder::new(tar_gz_file);
    let mut archive = Archive::new(tar_decoder);

    let extract_dir = temp_dir.path().join("extracted");
    fs::create_dir_all(&extract_dir)?;

    archive.unpack(&extract_dir)?;

    let chainstate_path = find_extracted_chainstate_directory(&extract_dir)?;

    println!(
        "Extracted chainstate data to: {}",
        chainstate_path.display()
    );

    Ok(chainstate_path)
}

/// Find the extracted chainstate directory
fn find_extracted_chainstate_directory(
    extract_dir: &Path,
) -> Result<PathBuf, Box<dyn std::error::Error>> {
    // Look for chainstate directory
    let possible_paths = [
        extract_dir.join("chainstate"),
        extract_dir.join("./chainstate"),
        extract_dir.to_path_buf(), // Might be extracted directly
    ];

    for path in &possible_paths {
        if path.exists() && path.is_dir() {
            // Verify it looks like a LevelDB directory
            if path.join("CURRENT").exists()
                || path.read_dir()?.any(|entry| {
                    entry
                        .map(|e| e.file_name().to_string_lossy().ends_with(".ldb"))
                        .unwrap_or(false)
                })
            {
                return Ok(path.clone());
            }
        }
    }

    Err(format!(
        "Could not find valid chainstate directory in extracted files at: {}",
        extract_dir.display()
    )
    .into())
}

#[test]
fn test_utxo_dump_help() {
    // Simple test to verify binary runs and shows help
    let output = Command::new("cargo")
        .args(["run", "--bin", "utxo-dump", "--", "--help"])
        .current_dir(".")
        .output()
        .expect("Failed to run utxo-dump --help");

    assert!(output.status.success(), "Help command should succeed");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(
        stdout.contains("utxo-dump"),
        "Help should mention the program name"
    );
    assert!(
        stdout.contains("blockchain"),
        "Help should mention blockchain option"
    );
}
