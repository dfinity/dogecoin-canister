//! Integration tests for utxo-dump tool
//!
//! These tests run the actual utxo-dump binary against test chainstate data
//! and verify the output consistency using file hashing.
//!
//! ## Usage
//!
//! To run the integration tests:
//! ```bash
//! cargo test --test integration_tests
//! ```
//!
//! The Bitcoin mainnet chainstate data is present as `test-data/chainstate-btc-mainnet-250k.tar.gz`
//!
//! It has been generated by syncing the Bitcoin blockchain up to the first 250k blocks
//! ```bash
//! ./bitcoin-28.0/bin/bitcoind -datadir="./data" -stopatheight=250000
//! tar -czf chainstate.tar.gz ./data/chainstate/
//! ```


use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use sha2::{Digest, Sha256};
use tempfile::TempDir;
use flate2::read::GzDecoder;
use tar::Archive;

const SHA256_OUTPUT_BTC_MAINNET_250K: &str = "126a344114be2924db8ba757b9ca8bc83b0ed6161f5b866befd30a282a1fb82f";

/// Runs utxo-dump against test chainstate data and verifies the output hash matches expected value
#[test]
fn test_bitcoin_mainnet_250k_chainstate_regression() {
    // Integration test using the fixed Bitcoin mainnet chainstate (250k blocks)
    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let output_file = temp_dir.path().join("bitcoin_mainnet_250k_output.csv");
    
    let test_chainstate_path = extract_chainstate_data(&temp_dir, "chainstate-btc-mainnet-250k.tar.gz")
        .expect("Failed to extract Bitcoin mainnet chainstate data. Make sure tests/test-data/chainstate-btc-mainnet-250k.tar.gz exists.");

    println!("Testing with Bitcoin mainnet chainstate (250k blocks)...");

    // Run utxo-dump binary with Bitcoin setting
    let output = Command::new("cargo")
        .args(&[
            "run",
            "--bin", "utxo-dump",
            "--",
            "--db", test_chainstate_path.to_str().unwrap(),
            "--output", output_file.to_str().unwrap(),
            "--blockchain", "bitcoin",
            "--quiet"
        ])
        .current_dir(".")
        .output()
        .expect("Failed to run utxo-dump");

    if !output.status.success() {
        panic!(
            "utxo-dump failed with Bitcoin mainnet chainstate!\nExit code: {}\nstdout: {}\nstderr: {}", 
            output.status.code().unwrap_or(-1),
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );
    }

    assert!(output_file.exists(), "Output file was not created");
    let file_contents = fs::read(&output_file)
        .expect("Failed to read output file");
    assert!(file_contents.len() > 0, "Output file is empty");

    let mut hasher = Sha256::new();
    hasher.update(&file_contents);
    let result_hash = hasher.finalize();
    let hash_hex = format!("{:x}", result_hash);

    let output_str = String::from_utf8_lossy(&file_contents);
    
    assert!(output_str.contains("height,txid,vout"),
            "Output doesn't contain expected CSV header");
    
    let line_count = output_str.lines().count();
    println!("=== BITCOIN MAINNET 250K TEST RESULTS ===");
    println!("Output file hash: {}", hash_hex);
    println!("Output file size: {} bytes", file_contents.len());
    println!("Total lines: {} (including header)", line_count);
    
    println!("First few lines of output:");
    for (i, line) in output_str.lines().take(10).enumerate() {
        println!("  {}: {}", i + 1, line);
    }

    assert!(line_count > 1, "Should have at least header + some UTXO entries");
    
    assert_eq!(hash_hex, SHA256_OUTPUT_BTC_MAINNET_250K,
        "Bitcoin mainnet 250k output hash does not match expected value");
}

/// Extract chainstate.tar.gz file in the test-data directory
/// Returns path to the extracted chainstate directory
fn extract_chainstate_data(temp_dir: &TempDir, filename: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {
    let test_data_path = find_test_chainstate_path(filename)?;
    
    let tar_gz_file = fs::File::open(&test_data_path)?;
    let tar_decoder = GzDecoder::new(tar_gz_file);
    let mut archive = Archive::new(tar_decoder);
    
    let extract_dir = temp_dir.path().join("extracted");
    fs::create_dir_all(&extract_dir)?;
    
    archive.unpack(&extract_dir)?;

    let chainstate_path = find_extracted_chainstate_directory(&extract_dir)?;
    
    println!("Extracted chainstate data to: {}", chainstate_path.display());
    
    Ok(chainstate_path)
}

/// Find the test chainstate.tar.gz file in the tests/test-data directory
fn find_test_chainstate_path(filename: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {
    // Try multiple possible locations for the test data
    let possible_paths = [
        PathBuf::from("tests/test-data").join(filename),
        PathBuf::from("test-data").join(filename),
        PathBuf::from("../tests/test-data").join(filename),
    ];
    
    for path in &possible_paths {
        if path.exists() {
            return Ok(path.clone());
        }
    }
    
    Err(format!(
        "Test data file '{}' not found. Tried locations:\n{}",
        filename,
        possible_paths.iter()
            .map(|p| format!("  - {}", p.display()))
            .collect::<Vec<_>>()
            .join("\n")
    ).into())
}

/// Find the extracted chainstate directory
fn find_extracted_chainstate_directory(extract_dir: &Path) -> Result<PathBuf, Box<dyn std::error::Error>> {
    // Look for chainstate directory
    let possible_paths = [
        extract_dir.join("chainstate"),
        extract_dir.join("./chainstate"),
        extract_dir.to_path_buf(), // Might be extracted directly
    ];
    
    for path in &possible_paths {
        if path.exists() && path.is_dir() {
            // Verify it looks like a LevelDB directory
            if path.join("CURRENT").exists() || 
               path.read_dir()?.any(|entry| {
                   entry.map(|e| e.file_name().to_string_lossy().ends_with(".ldb")).unwrap_or(false)
               }) {
                return Ok(path.clone());
            }
        }
    }
    
    Err(format!(
        "Could not find valid chainstate directory in extracted files at: {}",
        extract_dir.display()
    ).into())
}

#[test]
fn test_utxo_dump_help() {
    // Simple test to verify binary runs and shows help
    let output = Command::new("cargo")
        .args(&["run", "--bin", "utxo-dump", "--", "--help"])
        .current_dir(".")
        .output()
        .expect("Failed to run utxo-dump --help");

    assert!(output.status.success(), "Help command should succeed");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("utxo-dump"), "Help should mention the program name");
    assert!(stdout.contains("blockchain"), "Help should mention blockchain option");
}
